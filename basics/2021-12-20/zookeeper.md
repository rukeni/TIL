# Zookeeper

## 소개

- 분산된 시스템간의 정보를 공유하는 방법
- 분산 시스템내에서 중요한 상태 정보나 설정 정보등을 유지
- 코디네이션 서비스의 장애는 전체 시스템의 장애를 유발
    - 이중화 등을 이용하여 고 가용성을 만들어야 한다.
    - HBase, Kafka등에 이미 사용중
- 데이터 액세스가 빠르며 자체적인 장애 대응을 가진다.
- 자체적인 클러스터링을 제공
- 장애에도 데이터 유실 없이 fail over || fail back 이 가능하다.
- 기능
    - 디렉토리 구조 기반
    - znode라는 데이터 저장 객체 사용(key-value)
    - 객체에 데이터를 넣고 빼는 기능만 제공
    - 일반적인 디렉토리 구조 사용
    - 계층화된 구조
    

## 데이터 모델

![Zookeeper%207a1dc2bfec4b4b94a8adf2b374b48a4b/zookeeper_data.png](Zookeeper%207a1dc2bfec4b4b94a8adf2b374b48a4b/zookeeper_data.png)

- Persistent Node: 노드에 데이터를 저장하면 일부러 삭제하지 않는 이상 삭제되지 않고 영구히 저장된다.
- Ephemeral Node: 노드를 생성한 클라이언트의 세션이 연결되어 있을 경우만 유효하다. 즉 클라이언트 연결이 끊어지는 순간 삭제 된다.
- Sequence Node: 노드를 생성할때 자동으로 sequence 번호가 붙는 노드이다. 주로 분산락을 구현하는데 이용된다.
- Watcher: zookeeper 클라이언트가 znode에 watch를 걸어놓으면, 해당 znode가 변경이 되었을때, 클라이언트로 callback 호출을 날려서 클라이언트에 해당 znode가 변경이 되었음을 알려준다. 그리고 해당 watcher는 삭제된다.

## ZooKeeper 활용 시나리오

- 큐 : Watcher와 Sequence node를 이용하면, 큐를 구현할 수 있는데, Queue 라는 Node를 만든 후에, 이 노드의 Child node를 sequence node로 구성하면, 새롭게 생성되는 메시지들은 이 sequence node로 순차적으로 생성된다. 이 큐를 받아서, 마치 메시지 Queue의 pub/sub 과 같은 형태의 효과를 낼 수 있다. 대용량 메세지나 어플리케이션 성격상의 메세지는 일반적인 큐 솔루션인 Rabbit MQ등을 활용하고, ZooKeeper는 클러스터간 통신용 큐로 활용하는 것을 고려해 볼 수 있다.
- 서버 설정 정보 : 가장 일반적인 용도로는 클러스터 내의 각 서버들의 설정 정보(Configuration)를 저장하는 저장소로 쓸 수 있다. 정보가 안정적으로 저장이 될 뿐 아니라. Watch 기능을 이용하면 설정 정보가 저장될 경우 각 서버로 알려서 바로 반영을 할 수 있다.
- 클러스터 정보 : 현재 클러스터에서 기동중인 서버 목록을 유지할 수 있다. Ephemeral Node는 Zookeeper 클라이언트가 살아 있을 경우에만 유효하기 때문에, 클러스터내의 각 서버가 Ephemeral Node를 등록하도록 하면, 해당 서버가 죽으면 Ephemeral Node가 삭제 되기 떄문에 클러스터 내의 살아 있는 Node 리스트만 유지할 수 있다. 조금 더 발전하면, 클러스터가 master/slave 구조일때, master 서버가 죽었을 때 다른 master 서버를 선출하는 election logic도 구현이 가능하다.
- 글로벌 락 : Zookeeper를 이용하여 많이 사용되는 시나리오 중의 하나인데, 여러개의 서버로 구성된 분산 서버가 공유 자원을 접근하려고 했을때, 동시에 하나의 작업만이 발생해야 한다고 할때, 그 작업에 Lock을 걸고 작업을 할 수 있는 기능을 구현할때 사용한다.

## 클러스트에 필요한 것

- 클러스터 내부 관리
    - 누가 죽었고 누가 살았는지
    - 누가 리더이고 누가 팔로우하는지
- 클러스터 내부 정보 공유
- 클러스터 내부 서버에 대한 동시 접근 제어

## ZooKeeper 개요

- 분산 시스템 통제 및 관리
- 서버
    - 서버 앙상블 : N개 서버로 구성된 단일 주키퍼 클러스터 구성
- 클라이언트
    - 앙상블에 속한 서버에 연결하여 서비스 사용
- 데이터 스토리지(영속 데이터 / 임시 데이터)
    - 클러스터 구성원 간 데이터 공유
- 데이터 변경 통제(Watch)
    - 클러스터 멤버십 관리
- 시퀀스 노드
    - 마스터, 분산 락 등에 활용

## Znodes

- 주키퍼는 계층을 가진 네임스페이스 구조를 이룬다.
- 각 계층을 ZNode라고 부른다.
    - ZNode는 '/'를 통해 각 경로를 구분한다.
    - 이는 파일시스템의 구조와 대동소이하다.
- ZNode는 데이터를 가질 수 있다.(byte[])
- Znode는 '/'구분을 통해 자식 노드를 가질 수 있다.
    - '/svc'노드와 '/svc/nodes'노드는 자식관계가 된다.
- 데이터는 두 종류를 가진다.
    - PERSISTENT: 클라가 종료되도 유지되는 데이터
    - EPHEMERAL: ZNode를 생성한 클라의 연결이 끊기면 삭제되는 데이터
        - 자식 znode를 가질 수 없다.

## 주요 명령어

- create
- delete
- exists
- getChildren
- getData
- setData
- 언어별 주키퍼 클라이언트 연결법
    - [https://cwiki.apache.org/confluence/display/ZOOKEEPER/ZKClientBindings](https://cwiki.apache.org/confluence/display/ZOOKEEPER/ZKClientBindings)
    

ZNode Watch

- ZNode의 변화를 통지 받음
- 오퍼레이션 실행시 Watcher에 등록
    - ex) zk.getChildren('/mysvc/nodes', watcher)
- 이벤트 종류
    - Watch 생성 오퍼레이션
        - exists
        - getData
        - getChildren
    - znode 생성
        - NodeCreated
    - znode 삭제
        - NodeDeleted
    - 자식 생성
        - NodeChildrenChanged
    - 자식 삭제
        - NodeChildrenChanged
    - znode 값 변경
        - NodeDataChanged

## Watch 특징

- 일회성 이벤트 수신
    - 다시 Watch하고 싶으면 재등록해야 함
    - 재등록 전에 발생한 변경은 수신하지 못함
- 상태 변경 요청한 클라가 성공 코드를 받은 이후에, Watcher를 등록한 클라에 통지 됨
- ZooKeeper의 변경 순서대로 Watch 이벤트를 수신 함

## 시퀀스 노드

- 자식 노드가 생성한 순서에 따라 일렬 번호를 가지게 되는 경우
    - '/svc'으 자식 노드로 '/nodes'를 시퀀스 노드 방식으로 생성하면 다음과 같이 생성됨.
    - '/svc/nodes0000000001'
    - '/svc/nodes0000000002'
- PERSISTENT와 EPHEMERAL 모두 가능
- 시퀀스 범위 (4 byte) : -2,147,483,647 ~ 2,147,483,647 (-21억 ~ 21억)

## 주키퍼의 용도 (1) - 그룹 관리 : 자식 ZNode, Watch

- 그룹 멤버십 목록을 가질 znode생성 : 예) '/members'
    - 멤버십 참여
        - 부모 znode에 자신을 위한 자식 znode를 ephemeral로 생성
            - 예) '/members/m-hostip'
        - 자식 znode 데이터는 다른 구성원이 자신과 통신하는데 필요한 정보 저장 (ip, port등)
    - 멤버십 탈퇴
        - 자신에 해당하는 자식 znode를 삭제
    - 멤버십 목록, 주기적 갱신 ( 각 클라 )
        - 주기적으로 getChildren 실행해서 목록 갱신
    - 멤버십 목록, Watch 이용 (각 클라 )
        - 부모 znode에 getChildren로 WATCH등록하고, getChildren 결과로 목록 갱신
        - NodeChildrenChanged 이벤트 수신 했을때, 위 과정 재 실행

## 주키퍼의 용도 (2) - 관리자 선출: 시퀀스 노드, Watch

- 마스터 후보를 보관할 znode 생성 예) '/masters/'
    - 마스터 후보 등록
        - 부모 znode에 자신을 위한 자식 znode를 시퀀스 & ephemeral로 생성
            - '/masters/m-000000000010'
    - 마스터 선출 (각 후보 클라에서 진행)
        - 부모 znode에 getChild로 Watch 등록
        - NodeChildrenChanged 이벤트 수신시 현재 마스터가 없는지 확인
        - 마스터가 해당하는 자식 znode가 없으면
            - 부모 znode에 자식 znode를 구한 후, 시퀀스 번호가 가장 작은 znode를 마스터로 선택
        - 부모 znode에 getChild로 Watch 등록
        

## 주키퍼의 용도 (3) - 분산 락 : EPHEMERAL 사용

## 주키퍼의 용도 (4) - 이벤트 통지 : WATCH 사용

## 주키퍼의 용도 (5) - pub/sub 구현 : SEQUENCE 사용

## 주키퍼의 용도 (6) - 분산 카운터 : SEQUENCE 또는 znode의 version 사용

## 주키퍼의 용도 (7) - 디렉토리 서비스 : 활성화된 서비스 목록 등 제공

## 주키퍼의 버전 관리

- zxid: ZooKeeper Transaction ID
    - 모든 변경은 고유 트랜잭션 ID를 가진다.
    - 순서를 가진다.
- version
    - znode가 변경될 떄 마다 버전 값은 증가한다.
- cversion
    - 자식 znode가 변경될 때 마다 버전 값은 증가한다.
    

## 주키퍼 서버와 클라이언트 연결

- 주키퍼 클라
    - 연결 유지를 위해 주기적으로 PING 전송
    - PING 전송 실패시, 다른 서버로 연결
    - 연결된 서버에서 읽기 실행
    - 연결된 서버에 변경 요청
- 주키퍼 서버
    - 일정 시간 동안 클라로 PING이 없으면 세션 종료 처리
    - 리더에 변경 요청을 전달하면, 리더가 트랜잭션 생성 후, 전 노드에 전파

## 주키퍼의 가용성과 데이터 변경

- 서버의 과반 이상 서버 다운시, 서비스 중지
    - 예) 2대 중 1대 다운되면 서비스 중지
    - 예) 3대 중 2대 다운되면 서비스 중지
    - 예) 5대 중 3대 다운되면 서비스 중지
    - 이런 이유로 서버 개수는 홀수로 맞춤
- 데이터 변경시 성공 기준
    - 리더 서버가 트랜잭션 생성 후 다른 서버에 전달할 때, 과반 이상 트랜잭션 성공하면 클라에 변경 성공 결과 리턴

## 주키퍼의 일관성 보장

- Sequential Consistency : 변경 요청은 순서대로 적용
- Atomicity: 변경은 성공 또는 실패, 애매한 결론은 없다.
- Single System Image: 클라는 연결한 서버에 상관없이 동일 서비스 사용
- Reliability: 클라가 성공 코드를 받으면 서버에 반영된다는 것을 보장
- Timeliness: 클라는 일정 시간내에 최신 상태를 사용 ( Eventual Consistency )

## 주키퍼를 사용하는 오픈소스 사례

- Hadoop : 마스터(Name Node) 이중화
- HBase : 마스터 선출, 리전 데이터 공유 등에 사용
- Storm : 서버 간 데이터 공유 등에 사용
- Kafka : 클러스터 관리
- Neo4j : 마스터 선출에 사용

## 주키퍼란 무엇인가?

- 분산시켜놓고 중앙화하여 관리하는 서비스
- 분산처리에 대한 부분(관리의 어려움, 상태의 변화 처리등) 지원
- 동기화, 환경 유지, 네이밍을 위한 높은 레벨의 서비스
- 친숙한 디렉토리 트리 구조
- 자바, C와의 연동

## 주키퍼의 설계 원칙

1. 심플하게
    1. 표준 파일 시스템과 유사
    2. 계층적 네임스페이스를 통해 분산 프로세스를 허용
        1. 주키퍼 내에선 각 네임스페이스를 znodes라고 불림
    3. 주키퍼 데이터는 메모리 상에서 유지
        1. 높은 처리량과 낮은 지연율 달성 가능
2. 복제되게
    1. 주키퍼 자체는 앙상블이라는 호스트들의 집합에 복제된다.
    2. 주키퍼 서비스로 지정된 서버들은 반드시 서로에 대해 알고 있어야 한다.
    3. 서비스는 상태의 메모리 이미지와 별도의 공간에 트랜잭션 로그와 스냅샷을 함께 가진다.
    4. 클라는 단일 주키퍼 서버에 연결한다.
    5. 클라는 TCP연결로 요청을 보내거나 응답을 받고 이벤트를 감시하며 하트비트를 보내는 것을 통해 유지한다.
    6. 주키퍼 서버가 사용 불가능해지면 클라이언트의 TCP 연결은 다른 주키퍼 서버로 연결된다.
3. 정렬되도록
    1. 주키퍼는 각각의 업데이트마다 숫자를 찍는다.
    2. 모든 주키퍼 트랜잭션 순서에 반영된다.
    3. 이후 동작은 동기호 가타은 고수준 추상화를 구현하기 위해 사용할 수 있다.
4. 빠르게
    1. 주키퍼는 읽기 지배적인 워크로드에서 빠르다.
    2. 주키퍼 어플리케이션은 수천개의 기기상에서 실행한다.
    3. 일반적으로 쓰기보다는 읽기에 적합한 수행을 한다.
    4. 대략적으로 읽기/쓰기의 비율은 10:1 정도이다.

## 데이터 모델과 계층적 네임스페이스

- 주키퍼의 네임 스페이스 즉, znodes는 표준 파일 시스템과 비슷하다.
- 이름은 슬래쉬로 분할하여 경로 순서를 지정하고 식별된다.
- 단, 표준 파일 시스템과 달리 각각의 노드는 연관된 자식의 데이터를 가진다.
    - 이것의 의미는 파일시스템에서 폴더가 파일을 가질 수 있는 것과 비슷하다(폴더의미 == znode)
    - 각 노드는 작은 데이터를 저장한다. 데이터의 크기는 바이트에서 킬로바이트 사이정도이다.
- znode는 데이터 변경, ACL 변경, 타임스탬프, 캐시 유효성과 관리된 업데이트를 허용하는 버전 숫자를 포함하는 상태 구조를 유지
- Znode의 데이터 변경이 일어나는 시간마다 버전 숫자가 증가 된다.
- 네임스페이스 내에서 각 Znode의 데이터는 자동적으로 읽고 쓰여진다.
- znode에서 연관된 모든 데이터를 읽고 전체 데이터를 교체해서 씁니다.
- 각 노드는 무엇을 할 수 있는지 제한할 수 있는 접근 제어 목록(ACL, Access Control List)을 가집니다.
- 주키퍼는 임시 노드의 개념을 가집니다.
- 임시 Znodes는 Znode가 활성화되어 만들어진 세션이 있는 한 존재한다.
- 세션을 종료 할 떄 임시 znode는 삭제된다.
- 임시 node는 개발될 것을 구현할 때 유용하다.
- 주키퍼는 감시의 개념을(Watch) 지원한다.
- 클라들은 Znode 상에서 감시를 설정할 수 있다.
- 감시는 znode가 변경 될 때 트리거 되거나 삭제 된다.
- 감시가 트리거 될 때 클라는 znode가 변경되었다고 전송하는 패킷을 받을 수 있다.
- 만약 클라와 하나의 주키퍼 서버와의 연결이 끊어지면 클라는 로컬 알림(local notification)을 받을 것이다.

## 보장하는 부분

- 동기화 같은 더 복잡한 서비스의 기초가 된다.
    - 순차적인 일관성 - 클라부터의 업데이트는 그들이 보내졌을 때 순서대로 적용된다.
    - 원자성 - 업데이트는 성공하거나 실패한다. 확실한 성공 || 확실한 실패
    - 단일 시스템 이미지 - 클라는 서버와 연결이 되어 있는 동안 서비스를 같은 시각으로 볼 수 있는 것이다.
    - 신뢰성 - 한번 업데이트가 적용되면, 이것은 클라가 업데이트를 덮어 쓰기 전까지 지속된다.
    - 적시성 - 시스템의 클라 관점은 특정 시간 내에 처리 될 수 있도록 보장한다.

## 사용 사례

분산 서버 간의 정보 공유, 서버 투입/제거 시 이벤트 처리, 서버 모니터링, 시스템 관리, 분산 락 처리, 장애 상황 판단

1. 클러스터 관리
    1. 그룹 관리할 znode를 생성
    2. 자식 znode에 필요한 정보를 저장
    3. 주기적으로 상태를 변경
    4. 탈퇴하고자 하는 경우 자신에 해당하는 znode를 삭제
    5. 멤버십 목록, 주기적 갱신 - 주기적으로 getChildren 실행해서 목록 갱신
    6. 멤버십 목록, Watch 이용 - 부모 znode에 getChildren 로 WATCH 등록하고 getChildren 결과 목록 갱신
    7. NodeChildrenChanged 이벤트 수신 시, 위 과정 재실행
    
2. 리더 선출
3. 분산 배타적 잠금
4. 기타 용도
    1. 이벤트 통지: WATCH 이용
    2. pub/sub : SEQUENCE 사용
    3. 분산카운터 : SEQUENCE 또는 znode의 version 사용
5.