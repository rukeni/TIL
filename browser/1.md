# 최신 웹브라우저 동작 원리

## 브라우저의 주요 기능

- 웹 자원을 서버에 요청하기
- 브라우저 창에 리소스를 표시하는 것

## 브라우저의 HTML파일 해석 방법과 표시 방법

- 표준화 단체 W3C가 규정한 방법에 의거해서 해석하고 표시한다.
  
## 브라우저 공통 인터페이스 UI

- 주소창
- 뒤로가기 버튼 앞으로 가기 버튼
- 북마크 기능
- 새로고침, 중단 버튼
- 홈으로 이동 버튼

## 브라우저의 상위 구조

1. 유저 인터페이스
   1. 주소 창
   2. 뒤로가기 버튼
   3. 북마크 메뉴
   4. 메인 윈도우를 제외한 나머지
2. 브라우저 엔진 : UI와 레이아웃 엔진 사이의 처리를 정리
3. 레이아웃 엔진 : 요청된 콘텐츠 표시를 담당
   1. 예를 들어 요청된 컨텐츠가 HTML이면 HTML과 CSS를 해석해서 해석된 컨텐츠를 화면에 표시한다.
4. 네트워킹 : HTTP 요청 등의 호출에 사용. 플랫폼에 의존하지 않는 인터페이스
5. UI 백엔드 : 플랫폼에 의존하지 않는 범용 인터페이스로 UI가 되어있음
   1. 콤보 박스와 윈도 등의 기본적인 위젯 묘사에 사용
6. 자바스크립트 해석기 : 자바스크립트의 해석과 실행에 사용
7. 데이터 스토리지 : 영속적인 레이어. 각종 데이터를 하드 디스크에 보존하는 방법

## 레이아웃 엔진

렌더링을 한다. 요청된 컨텐츠를 화면 표시시킨다.

HTML, XML문서를 표시한다. 다른 종류의 파일도 표시할 수 있다.

파이어폭스, 크롬, 사파리는 2개의 레이아웃 엔진 위에 구축되고 있다. Firefox에서는 Mozilla용 자체 렌더링 엔진인 Gecko를 사용한다. Safari와 Chrome에서는 Webkit를 사용한다.

Webkit은 오픈 소스 렌더링 엔진이다. Linux 플랫폼용 엔진으로 시작하여 Mac과 Windows에 대응하기 위해 개량 되었다.

[Webkit 링크](https://webkit.org/)

## 메인 플로우

렌더링 엔진은 우선 요청된 문서의 컨텐츠를 네트워킹 계층에서 취득한다. 이 처리는 8kb단위로 이루어진다.

### 렌더링의 기본 흐름

- HTML 파싱
- 렌더 트리 구축
- 렌더트리의 레이아웃
- 렌더트리 페인팅

렌더링 엔진은 HTML 문서 해석을 시작한다.

태그를 contents tree라는 트리 내의 DOM노드로 변환한다.

외부 CSS파일과 style요소 내의 스타일 데이터를 해석한다.

스타일 정보와 HTML 내의 시각적인 지시를 조합하고 렌더 트리이라는 다른 트리가 작성된다.

렌더 트리는 화면에 표시될 올바른 순서를 가지고 있다.

렌더 트리가 구축되면 레이아웃처리에 들어간다.

화면에 표시되는 정확한 좌표가 각 노드로 할당할 수 있다.

그다음은 페인팅이다. 렌더 트리가 주사되고 UI백엔드 레이어를 사용하고 각 노드가 페인팅된다.

이게 단계적 처리임을 잘 이해해야 한다. 모든 HTML이 해석되는 것을 기다렸다가, 렌더 트리의 구축과 레이아웃을 시작하는 것은 아니다.

컨텐츠의 일부가 해석되고 표시되는 동안, 네트워크로부터 남은 컨텐츠가 도착해서 처리가 계속된다.

Gecko에서는 용어는 다르지만 플로우는 같다.

Gecko에서는 시각적 서식이 설정된 요소 트리를 프레임 트리라고 부른다.

각 요소가 1개의 프레임이다.

Webkit에서는 렌더트리라는 용어가 사용되고 렌더 트리는 렌더 객체로 구성되어 있다.

Webkit에서는 요소를 배치하기를 레이아웃이라고 부르지만 Gecko에서는 리플로우라고 부른다.

Gecko에는 HTML과 DOM트리의 사이에 추가 레이어가 있다. "content sink"라고 부르며 DOM요소를 작성하기 위한 팩토리이다.

## 파싱 - 간단한 설명

파싱은 렌더링 엔진에서 매우 중요한 처리라 조금 자세히 봐야한다.

일단 간단한 설명부터 시작하자.

문서의 해석은 문서를 의미 있는 구조로 변환하는 것이다.

파싱 결과는 보통 문서의 구조를 나타내는 노드 트리가 된다.

이를 parse tree또는 syntax tree라고 한다.

## 문법

파싱은 그 문서가 따르는 구문 규칙에 근거한다.

포맷을 파싱하려면 그 포맷에 어휘와 구문 규칙의 결정론적인 문법이 없으면 안 된다.

이를 "Context Free Grammars"라고 한다.

인간의 언어는 그것에 해당되지 않기 때문에 기존의 해석 기법에서는 해석할 수 없다.

## 파서와 렉서의 조합

파싱은 렉시컬 분석과 신택스 분석으로 나뉜다.

렉시컬 해석은 입력을 토큰으로 분할하는 처리이다.

토큰은 인간의 어휘에 해당한다.

인간의 언어에서는 그 언어의 사전에 등장하는 모든 단어가 어휘를 구성하고 있다.

신택스 분석은 언어의 구문 규칙을 적용하는 것이다.

통상 파서에서는 처리를 2개의 구성 요소로 나누어 실시한다. 입력을 유효현 토큰으로 분할하는 lexer(렉서: tokenizer라고도 한다)와 언어의 구문 규칙으로 문서의 구조를 분석 및 해석 트리를 구축하는 파서이다.  렉서에는 공백 문자와 개행 등의 관계 없이 문자를 제외하는 기능이 있다.

도큐먼트 -> 렉시컬 분석 -> 신택스 분석 -> 구문 해석됨

파싱은 반복적인 처리과정이다.

파서는 통칭 렉서에 새로운 토큰을 요구하고 토큰을 구문 규칙의 하나로 통합하려고 한다.

규칙이 일치할 경우 그 토큰에 대응하는 노드가 파싱 트리에 추가되고 파서 별도의 토큰을 요구한다.

규칙이 일치하지 않는 경우는 토큰을 내부적으로 탑재하는 내부에 저장한 모든 토큰이 일치하는 규범을 찾을 때까지, 토큰을 요구한다.

규칙이 발견되지 않을 경우 파서는 예외를 생성한다. 문서가 유효하지 않고 구문 오류가 포함된거라고 간주한다.

## 변환

대부분의 경우 최종적으로 생성되는 것은 파싱 트리가 아니다. 파싱은 변환(입력된 문서를 다른 형식으로 변환하는것)에도 자주 사용된다.

예로 컴파일이 있다.

소스 코드를 기계 코드로 컴파일하는 컴파일러에서는 처음에 소스 코드를 해석하고 파싱 트리를 작성하고 다음으로 파싱 트리를 기계 코드 문서로 변환한다.

소스코드 -> 파싱 -> 파싱트리 -> 변환 -> 기계코드

## 파싱의 예

간단한 수학적 언어를 정의하고 분석 처리를 해보자.

어휘 : 이 언어에서는 정수와 플러스 기호 마이너스 기호가 있다.

구문

1. 이 언어의 구문 구성요소는 식, 항, 연산이다.
2. 이 언어에는 식을 몇가지라도 포함할 수 있다.
3. 항 뒤에 연산이 이어 다른 항이 계속된 것을 식이라고 정의한다.
4. 연산은 플러스 토큰 또는 마이너스 토큰이다.
5. 항은 정수 토큰이나 음식이다.

2 + 3 - 1 이 있다고 해보자.
룰에 일치하는 최초의 문자열 2는 규칙 5에 따르면 항이라고 불린다.

2번째로 일치하는 것은 2 + 3이다.

항 후에 연산이 이어 다른 규정이 계속되고 있으니, 규칙 3에 일치한다.

다음 일치를 입력의 끝까지 가면 2 + 3 - 1이 식이 된다.

이미 2+ 3 이 항이라는 것을 알고 있기에 항 후에 연산이 이어 다른 규정이 계속되고 있게 된다.

2 + + 라는 게 있다면 어떤 규정에도 속할 수 없기 때문에 무효인 입력이 된다.

## 어휘와 구문의 공식 정의

통상, 어휘는 정규 표현으로 나타낸다.

예를들어 다음과 같이 정의된다.

`INTEGER:0|[1-9][0-9]*PLUS: +MINUS: -`

정수는 정규 표현으로 정의되어 있다.

구문은 통상 BNF형식으로 정의한다. 샘플은 다음과 같다.

`expression:=term  operation  term
operation:=PLUS|MINUS
term:=INTEGER|expression`
