# 함수형 반응형 프로그래밍

> 함수형 프로그래밍은 병렬성에 대한 진정한 해법을 제공한다.

-> 어떻게?

## 함수형 반응형 프로그래밍이란?

* FRP는 자주 쓰이는 옵저버 패턴을 대치한다. 옵저버 패턴을 리스너나 콜백이라고도한다.
* FRP는 이벤트 위주의 로직을 조합 가능한 모듈로 코딩하는 방법이다.
* FRP는 다른 방식으로 사고한다. 프로그램을 입력에 대한 반응 또는 데이터의 흐름으로 표현한다.
* FRP는 프로그램 상태를 관리하는 데 질서를 부여한다.
* FRP는 근본적인 방법으로 옵저버 패턴으로 문제를 해결하려고 노력하는 사람이라면 결국에는 FRP를 발명하게 될 것이라고 생각한다.
* FRP는 일반적인 프로그래밍 언어의 경량 소프트웨어 라이브러리로 구현된다.
* FRP는 상태가 있는 로직을 위한 완전한 내장 언어라고 볼 수 있다.

-> 옵저버 패턴이란? 관찰하고 있는 객체가 변화를 야기했을 때 옵저버에 변화를 통보하고 관리하는 패턴을 뜻한다.

## 코날 엘리엇이 말하는 FRP의 특성

* 표시적(지시적)
  * 각각의 타입과 구성요소의 의미를 정확하게 엄밀하게 단순하게 지정
* 시간 연속적
  
## 우리가 사용하는 이벤트 리스너의 6가지 재앙

1. 예측 불가능한 순서: 리스너가 복잡하게 얽혀 있다면 이벤트가 도착하는 순서는 작성자가 등록한 순서에 따라 정해지는데 이 방식은 도움이 되지 않는다.
2. 첫 번쨰 이벤트 소실: 생산자가 첫 번째 이벤트를 생산하기 전에 리스너가 등록되리라 보장하기 어렵다. FRP는 트랜잭션 방식이기때문에 이를 보장한다.
3. 지저분한 상태: 콜백으로 인해 코드가 전통적인 상태 머신 형태로 바뀌며 지저분해지기 쉽다.
4. 스레드 문제: 리스너를 스레드 안전하게 만들려 하다가 교착상태를 일으킬 수 있다. 리스너가 등록 해제된 다음에는 호출되지 않도록 보장하기도 어려울 수 있다.
5. 콜백 누수: 리스너를 해제하는 것을 잊는 다면 메모리 누수가 발생. 리스너는 자연적인 데이터 의존성을 뒤집어주지만 생존 의존성을 뒤집어주지는 않는다.
6. 의도치 않은 재귀: 로컬 상태 갱신과 리스너 통지의 순서가 매우 중요한데 순서를 정할 때 실수하기 쉽다.

-> 즉, 순서처리 신경안써도됨. 트랜잭션 보장방식, 깨끗한 코드, 스레드 관리문제 해결, 메모리 누수 방지, 실수 방지가 FRP가 기존 리스너에 비견하여 제공해주는 이점이다.

## FRP는 어떻게 동작하는가?

### FRP의 두 가지 기본 데이터 타입

* 셀(cell)은 시간에 따라 변화하는 값을 표현
* 스트림(stream)은 이벤트의 흐름을 표현

## FRP의 핵심

* Stream과 Cell타입
* 기본 연산: map, merge, hold, snapshot, filter, lift, never, constant
* StreamLoop와 CellLoop를 통한 전방 참조
* hold와 snapshot을 사용해 누적기 만들기

## 참조 투명성

FRP가 제대로 동작하려면 map에 전달하는 함수가 반드시 참조 투명성(referential transparency)을 보장해야한다. 다른 표현으로 순수하다고 한다.

* I/O를 수행해서는 안된다.
* 함수 내부에서 예외를 던지는 경우에는 꼭 그것을 잡아서 처리해야만 한다. 함수 밖으로 예외가 나가도록 방치해서는 안된다.
* 변경 가능한 외부 변수의 값을 함수 내부에서 읽어서는 안 된다. 하지만 값이 변할 수 없는 변수가 상수를 읽는것은 가능하며 권장되는 일이다.
* 외부에서 볼 수 있는 변수의 상태를 변경해서는 안 된다.
* 함수 호출과 호출 사이에 지속되는 상태를 유지해서는 안된다.
* 짧게 말해, 함수는 반환값을 제외한 외부 효과를 만들어서는 안되며, 함수의 반환값이 외부 상태에 의해 영향 받는 일도 없어야 한다.

-> 참조 투명성을 테스트하는 한 가지 방법은 같은 값을 인자로 넘겼을 때 항상 출력값이 같은지 보는 것이다.
