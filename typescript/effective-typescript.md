# 이펙티브 타입스크립트

# 아이템 1 타입스크립트와 자바스크립트의 관계 이해하기

## 타입스크립트는 자바스크립트의 슈퍼셋이다.

.js 파일을 .ts 파일로 바꾼다고 뭔가 변하지 않는다. 오히려, 거기에 추가적인 기능을 더 쓸 수 있게 된다.

타입스크립트는 타입을 추론한다. 이를 통해 오류가 어디에서 발생했는지 찾을 수 있고, 제시된 해결책도 올바르다(P.6) 타입스크립트의 도움을 받으면 오류가 적은 코드를 작성할 수 있다.

# 아이템 2 타입스크립트 설정 이해하기

## 설정파일은 tsx —init만으로 간단히 생성된다.

타입스크립트는 타입 정보를 가질 때 가장 효과적이기 때문에, 되도록이면 noImplicitAny를 설정해야 한다. 모든 변수에 타입을 명시하는 것에 익숙해지면, noImplicitAny가 없는 채로 작성된 타입스크립트는 완전히 다른 언어처럼 느껴질 것이다.(P.11) noImplicitAny는 오로지 자바스크립트 프로젝트에서 타입스크립트 프로젝트로 전환하는 상황에만 필요하다.

 strictNullChecks는 null과 undefined가 모든 타입에서 허용되는지 확인하는 설정이다. 이 두가지 체크를 모두 설정하고 싶다면, strict : true로 두면된다. 

# 아이템 3 코드 생성과 타입이 관계없음을 이해하기

## 타입 오류가 있어도 컴파일은 가능하다.

만약 오류가 있을 때 컴파일하지 않으려면, noEmitOnError를 설정하거나 빌드 도구에 동일하게 적용하면 된다.

## 런타임에는 타입 체크가 불가능하다.

instanceof 체크 처럼 런타임에 작동하는 로직에 타입을 집어 넣으면 아무 역할도 할 수없다. 타입은 'erasable'하고 타입 구문은 컴파일 과정에서 모두 제거되어 버린다. 만일 instanceof로 체크를 하고 싶다면 interface라는 타입선언이 아닌 class로 선언하면 된다.

## 타입 연산은 런타임에 영향을 주지 않는다.

타입은 런타임 동작에 아무런 영향을 끼치지 않는다. 단지 타입을 체크하고 연산을 통해 변환을 수행해야한다.

## 런타임 타입은 선언된 타입과 다를 수 있다.

타입스크립트에서는 런타임 타입과 선언된 타입이 맞지 않을 수 있다. 타입이 달라지는 혼란스러운 상황을 가능한 피해야한다.

## 타입스크립트 타입으로는 함수를 오버로드할 수 없다.

타입스크립트는 타입이 런타임과 무관하기 때문에 함수 오버로딩을 할수없다. 

## 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.

타입스크립트의 정적 타입은 실제로 비용이 전혀 들지 않는다. 타입스크립트를 쓰는 대신 런타임 오버헤드를 감수하며 타입 체크를 한다면, 타입스크립트 팀이 다음 주의사항들을 얼마나 잘 테스트 해왔는지 몸소 느낄것이다. 런타임 오버헤드가 없는 대신, 컴파일 빌드타임 오버헤드가 있다. 컴파일은 일반적으로 빠른 편이며 증분 빌드 시에 더욱 체감된다. 타입스크립트는 오래된 런타임 환경을 지원하기 위해 일부 오버헤드와 성능을 트레이드오프로 둔다. 만약 호환성을 선택한다면, 특정 헬퍼 함수를 추가할 것이다.

# 아이템 4 구조적 타이핑에 익숙해지기

## 자바스크립트는 덕 타이핑 기반이다.

함수의 매개변수 값이 모두 제대로 주어진다면, 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용한다. 

 

# 아이템 5 any 타입 지양하기

## 타입스크립트의 타입 시스템은 점진적이고 선택적이다. 코드에 타입을 조금씩 추가할 수 있기 때문에 점진적이며, 언제든지 타입체커를 해제할 수 있기 때문에 선택적이다.

any타입을 사용하면 일부 특별한 경우를 제외하고 타입스크립트의 장점을 전혀 사용하지 못하게 된다.

## any 타입에는 타입 안전성이 없다.

타입 체커는 선언에 따라 어떤타입이든지 판단할 것이고 혼돈은 걷잡을 수 없게 된다.

## any는 함수 시그니처를 무시해 해버린다.

함수를 작성할 때는 시그니처를 명시해야한다. 입력과 약속된 출력을 반환한다. 그러나 any 타입 사용은 이러한 약속을 어길 수 있게 된다.

## any타입에는 언어 서비스가 적용되지 않는다.

자동완성 기능과 적절한 도움말을 받을 수 없게 된다.

## any 타입은 코드 리팩토링 때 버그를 감춘다.

문제가 있음에도 문제 없다고 타입 체커를 통과할 것이고 런타임에서 오류를 뱉어낸다.

## any는 타입 설계를 감춰버린다.

타입 설계가 불분명해지면서 설계가 잘 되었는지 설계가 어떤지 전혀 알 수 가 없어진다.

## any는 타입시스템의 신뢰도를 떨어뜨린다.

any를 쓰지 않으면 런타임에 발견될 오류를 미리 잡을 수 있고 신뢰도를 높인다.